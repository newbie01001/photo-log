# Cloudinary Implementation Logic

This document outlines the logic and integration of Cloudinary within the codebase, covering its core functionality, specific use cases, deletion strategies, upload limits, and database integration.

## 1. Core Integration & Configuration

*   **`app/services/cloudinary.py`**: This module centralizes all direct interactions with the Cloudinary API.
    *   **Configuration**: Cloudinary is configured using `cloudinary.config(cloudinary_url=settings.cloudinary_url)`, which retrieves the Cloudinary URL from the application's environment variables (`.env` file).
    *   **`upload_image` Function**: Takes a FastAPI `UploadFile` object and an optional `public_id`. It reads the file content into memory and uploads it to Cloudinary using `cloudinary.uploader.upload`. The `overwrite=True` option is used to replace existing assets with the same `public_id`.
    *   **`delete_image` Function**: Takes a `public_id` as an argument and uses `cloudinary.uploader.destroy` to remove the corresponding asset from Cloudinary.

## 2. Specific Use Cases & Features

Cloudinary is integrated into various parts of the application to handle image uploads and management:

*   **Event Cover Images (`app/routers/events.py`)**:
    *   When a host uploads an event cover image, the `upload_image` service is called.
    *   The full-size image's `secure_url` is stored in the `event.cover_image_url` field in the database.
    *   A thumbnail URL is automatically generated by Cloudinary using a transformation (`width=400, height=400, crop='fill'`) and stored in `event.cover_thumbnail_url`.
    *   The `file_size` of the uploaded cover image (in bytes) is recorded in `event.cover_image_file_size`.

*   **Public Photo Uploads (`app/routers/public.py`)**:
    *   Public users can upload photos to an event (with optional password protection).
    *   The `upload_image` service is used, and the `secure_url` and `thumbnail_url` are generated and stored in the `PhotoModel`.
    *   The `file_size` of the photo is recorded.
    *   **Quota Tracking**: For enforcing the host's upload limit, the `uploaded_by` field in the `PhotoModel` is set to the `host_id` of the event.
    *   **Anonymous Uploader Identification**: A unique `public_uploader_identifier` (a UUID) is generated and stored for each public upload. This allows for filtering or tracking by the anonymous uploader, separate from the host's quota.

*   **User Avatars (`app/routers/profiles.py`)**:
    *   Authenticated users can upload their profile pictures.
    *   The `upload_image` service is used. The full-size `secure_url` is stored in `db_user.avatar_url`.
    *   A thumbnail URL is generated (with a `width=150, height=150, crop='fill'` transformation) and stored in `db_user.avatar_thumbnail_url`.
    *   The `file_size` of the avatar is recorded in `db_user.avatar_file_size`.

## 3. Deletion Logic

To prevent orphaned assets in Cloudinary and manage storage efficiently, corresponding Cloudinary assets are deleted when their database records are removed:

*   **Photos (`app/routers/photos.py`)**: When a photo is deleted (individually or in bulk), its `public_id` is extracted from its URL, and the `delete_image` service is called to remove the asset from Cloudinary *before* the database record is deleted.
*   **Event Covers (`app/routers/admin.py`)**: When an event is force-deleted by an administrator, the event's cover image `public_id` is extracted, and `delete_image` is called.
*   **All Event Photos (`app/routers/admin.py`)**: During an admin-initiated force-delete of an event, all associated photos' `public_id`s are extracted, and `delete_image` is called for each.
*   **User Avatars (`app/routers/profiles.py`)**: When a user uploads a *new* avatar, the `public_id` of their *old* avatar (if one existed) is extracted, and `delete_image` is called to remove the old asset from Cloudinary.

## 4. Upload Limits (1GB per Authenticated User)

A 1GB total upload limit is enforced for each authenticated user (hosts/admins):

*   **`app/crud.py`**: A `get_user_upload_size` function calculates the total size of all files associated with a given `user_id`. This sum includes:
    *   `PhotoModel.file_size` for photos where `uploaded_by` matches the `user_id` (this covers both direct uploads by the user and public uploads to their events).
    *   `EventModel.cover_image_file_size` for event covers where the event's host matches the `user_id`.
    *   `UserModel.avatar_file_size` for the user's avatar.
*   **Enforcement**: Before any authenticated upload (event cover, avatar, or public photo to an event), the `get_user_upload_size` function is called. If the `current_upload_size + new_file_size` exceeds 1GB, an `HTTPException` (413 Request Entity Too Large) is raised, preventing the upload.

## 5. PostgreSQL Integration

The PostgreSQL database is used to store metadata about the Cloudinary assets:

*   **New Columns**: New columns were added to the `Event`, `Photo`, and `User` SQLAlchemy models to store:
    *   `cover_thumbnail_url`, `cover_image_file_size` (in `EventModel`)
    *   `thumbnail_url`, `file_size`, `public_uploader_identifier` (in `PhotoModel`)
    *   `avatar_url`, `avatar_thumbnail_url`, `avatar_file_size` (in `UserModel`)
*   **Database Migrations**: Alembic migrations were generated and applied to update the database schema, ensuring these new columns exist.
*   **Pydantic Models**: Corresponding Pydantic models (`EventResponse`, `PhotoResponse`, `UserResponse`, `UpdateProfileRequest`) were updated to include these new fields, facilitating proper data validation and serialization in API requests and responses.

This comprehensive integration ensures efficient Cloudinary asset management, robust storage limit enforcement, and consistent data handling across the application.
